# Design_Pattern
디자인 패턴을 학습, 노션에 정리한 뒤, 직접 구현하는 과정을 기록하는 레포지토리

## 디자인 패턴

---

    그동안 MVC와 MVVM 같은 디자인 패턴들은 단순한 개념 이해만 존재할 뿐, 어떤 의미를 가지고 있는 지 알고 있는 것은 아니였다. 하지만 이는 학습을 진행할 수록 의문점이 되었으며, 제대로 된 개념을 정립할 필요성을 느껴 정리하려고 한다. 

    **디자인 패턴이란, 발생할 수 있는 문제를 피하기 위한 패턴이다.** 협업하는 과정에 있어 어떠한 컨벤션도 존재하지 않는다면 많은 문제들이 발생할 것이다. 다른 사람의 코드를 이해하는 것에 많은 시간을 소비할 것이며, 코드를 수정하는 작업은 시도하는 것 조차 어렵게 느껴질 것이다. 이런 문제들은 그동안 많은 사람들이 겪어왔으며, 이를 해결하기 위해 여러 검증과정을 거친 뒤 제시된 하나의 설계도라고 볼 수 있다. 

    이러한 패턴들은 크게 3가지로 분류할 수 있으며 다음과 같은 패턴으로 분류된다. 

1. 생성 패턴
2. 구조 패턴 
3. 행동 패턴

### 생성 패턴

생성 패턴이란, 객체의 유연성과 재사용성을 증가시키는 패턴을 의미한다. 다양한 메커니즘이 존재하며, 객체 생성 과정에서 발생할 수 있는 문제들을 해결할 수 있다.

- 싱글톤 패턴 : 클래스의 인스턴스를 하나만 만들고 전역 레벨로 접근이 가능하도록 한다.
- 팩토리 메서드 패턴 : 객체의 생성을 서브 클래스에 위임한다.
- 추상 팩토리 패턴 : 관련된 객체 그룹을 생성할 수 있는 인터페이스를 제공한다.
- 빌더 패턴 : 복잡한 객체의 생성 과정을 단계별로 나누어 조립한다.
- 프로토타입 패턴 : 기존 객체를 복사해 새로운 객체로 생성한다.

### 구조 패턴

구조 패턴이란, 구조를 유연하고, 효율적일 수 있도록 유지하며, 클래스와 객체를 더 큰 구조로 조립하는 방법을 의미한다.

- 어댑터 패턴 : 인터페이스가 호환되지 않는 클래스들을 함께 작동하도록 구성한다.
- 브리지 패턴 : 추상층을 분리하여 여러 클래스들을 독립적으로 변형할 수 있도록 한다.
- 컴포지트 패턴 : 객체를 트리 구조로 구성, 이러한 트리 구조들이 개별의 객체처럼 작동할 수 있도록 한다.
- 데코레이터 패턴 : 객체의 추가적인 책임을 동적으로 부여한다.
- 파샤드 패턴 : 복잡한 처리들을 대신 수행하여 결과값만 넘겨주는 객체를 의미한다.

### 행동 패턴

행동 패턴은 객체나 클래스간의 상호작용과 책임 분담을 다룬다.

- 옵저버 패턴 : 객체의 상태 변화를 감지하고, 구독된 객체들에게 통지하여 이벤트를 발생시키는 패턴.
- 상태 패턴 : 객체의 상태에 따라 다른 행동을 할 수 있도록 상태를 캡슐화 하는 패턴.
- 전략 패턴 : 동일 계열의 알고리즘들을 캡슐화하여, 상호 교체가 가능하도록 하는 패턴
- 템플릿 메서드 패턴 : 알고리즘의 구조를 정의하고, 일부 단계를 서브클래스에서 구현하도록 하는 패턴.
- 이터레이터 패턴 : 배열을 노출하지 않고, 그 요소들에 순차적으로 접근할 수 있는 방법을 제공하는 패턴.
- 책임 연쇄 패턴 : 요청을 처리할 수 있는 여러 객체가 연결, 수행할 수 있으면 처리, 아니라면 다음 객체로 넘기는 형태